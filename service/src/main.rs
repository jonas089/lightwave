use core::fmt;
use std::{fmt::Debug, time::Instant};

use alloy_sol_types::SolType;
use anyhow::{Context, Result};
use beacon_electra::{
    extract_electra_block_body, get_beacon_block_header, get_electra_block,
    types::electra::ElectraBlockHeader,
};
use preprocessor::Preprocessor;
use recursion_types::{RecursionCircuitInputs, RecursionCircuitOutputs, WrapperCircuitInputs};
mod helpers;
use sp1_helios_primitives::types::{ProofInputs as HeliosInputs, ProofOutputs as HeliosOutputs};
use sp1_sdk::{HashableKey, ProverClient, SP1ProofWithPublicValues, SP1Stdin, include_elf};
mod preprocessor;
use tree_hash::TreeHash;
pub const HELIOS_ELF: &[u8] = include_bytes!("../../elf/sp1-helios-elf");
pub const RECURSIVE_ELF: &[u8] = include_elf!("recursion-circuit");
pub const WRAPPER_ELF: &[u8] = include_elf!("wrapper-circuit");

/// ServiceState maintains the state of the light client service, including
/// the most recent proof and trusted state information.
pub struct ServiceState {
    /// The hash of the genesis sync committee, stored for convenience
    pub genesis_committee_hash: Option<String>,
    /// The most recent recursive proof generated by the service
    pub most_recent_proof: Option<SP1ProofWithPublicValues>,
    /// The last trusted slot from our recursive proof outputs
    pub trusted_slot: u64,
    /// The last trusted execution block height
    pub trusted_height: u64,
    /// The current trusted state root
    pub trusted_root: [u8; 32],
    /// Counter that increases with every recursive proof
    pub update_counter: u64,
}

impl Debug for ServiceState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ServiceState")
            .field("genesis_committee_hash", &self.genesis_committee_hash)
            .field(
                "most_recent_proof_outputs",
                &self.most_recent_proof.as_ref().map(|proof| {
                    borsh::from_slice::<RecursionCircuitOutputs>(&proof.public_values.to_vec())
                        .map(|outputs| format!("{:?}", outputs))
                        .unwrap_or_default()
                }),
            )
            .field("trusted_slot", &self.trusted_slot)
            .field("trusted_root", &hex::encode(self.trusted_root))
            .field("counter", &self.update_counter)
            .finish()
    }
}

/// Main entry point for the light client service.
///
/// This function:
/// 1. Initializes the service state with a trusted slot
/// 2. Sets up the prover client and circuit artifacts
/// 3. Enters a loop that:
///    - Generates Helios proofs for new blocks
///    - Verifies proofs recursively
///    - Updates the service state with new trusted information
///    - Commits execution block height and state root instead of beacon header
#[tokio::main]
async fn main() -> Result<()> {
    let start_time = Instant::now();
    let mut service_state = ServiceState {
        genesis_committee_hash: None,
        most_recent_proof: None,
        // must be initialized correctly
        trusted_slot: 7584512,
        // can be initialized correctly, but doesn't have to be.
        trusted_height: 0,
        trusted_root: [0; 32],
        update_counter: 0,
    };
    dotenvy::dotenv().ok();
    let consensus_url = std::env::var("SOURCE_CONSENSUS_RPC_URL").unwrap_or_default();
    let client = ProverClient::from_env();
    loop {
        let (helios_pk, helios_vk) = client.setup(HELIOS_ELF);
        let (recursive_pk, recursive_vk) = client.setup(RECURSIVE_ELF);
        let (wrapper_pk, wrapper_vk) = client.setup(WRAPPER_ELF);
        let preprocessor = Preprocessor::new(service_state.trusted_slot);

        let inputs = match preprocessor.run().await {
            Ok(inputs) => inputs,
            Err(e) => {
                println!("[Warning]: {:?}", e);
                tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;
                continue;
            }
        };
        let mut stdin = SP1Stdin::new();
        stdin.write_slice(&inputs);

        // if this is the first proof, we want to store the active committee as our genesis committee
        if service_state.update_counter == 0 {
            let helios_inputs: HeliosInputs = serde_cbor::from_slice(&inputs)?;
            service_state.genesis_committee_hash = Some(hex::encode(
                helios_inputs
                    .store
                    .current_sync_committee
                    .clone()
                    .tree_hash_root()
                    .to_vec(),
            ));
            //////////////////////////////////////////////////////////////
            //////////////////////////////////////////////////////////////
            // optional when initializing the circuit
            /*println!(
                "Genesis Committee Hash Bytes, please copy into the circuit: {:?}",
                helios_inputs
                    .store
                    .current_sync_committee
                    .clone()
                    .tree_hash_root()
                    .to_vec(),
            );*/
            //////////////////////////////////////////////////////////////
            //////////////////////////////////////////////////////////////
        }

        let proof = match client
            .prove(&helios_pk, &stdin)
            .groth16()
            .run()
            .context("Failed to prove")
        {
            Ok(proof) => proof,
            Err(e) => {
                println!("Proof failed with error: {:?}", e);
                continue;
            }
        };

        let helios_outputs: HeliosOutputs =
            HeliosOutputs::abi_decode(&proof.public_values.to_vec(), false).unwrap();

        // Prepare additional circuit inputs that depend on the newHead from the Helios proof
        // We don't know this value until after proof generation, therefore we need to fetch
        // some additional information to verify the state root and height against the Helios beacon header
        // and slot number
        let electra_block =
            get_electra_block(helios_outputs.newHead.try_into()?, &consensus_url).await;

        // Extract the body roots from the Electra block
        let electra_body_roots = extract_electra_block_body(electra_block);

        // Get the header from the Electra block
        let beacon_header =
            get_beacon_block_header(helios_outputs.newHead.try_into()?, &consensus_url).await;

        let electra_header = ElectraBlockHeader {
            slot: beacon_header.slot.as_u64(),
            proposer_index: beacon_header.proposer_index,
            parent_root: beacon_header.parent_root.to_vec().try_into().unwrap(),
            state_root: beacon_header.state_root.to_vec().try_into().unwrap(),
            body_root: beacon_header.body_root.to_vec().try_into().unwrap(),
        };

        // generate the recursive proof
        let previous_proof = if service_state.update_counter == 0 {
            None
        } else {
            Some(
                service_state
                    .most_recent_proof
                    .expect("Missing previous proof in state"),
            )
        };

        let recursion_inputs = RecursionCircuitInputs {
            electra_body_roots,
            electra_header,
            helios_proof: proof.bytes(),
            helios_public_values: proof.public_values.to_vec(),
            helios_vk: helios_vk.bytes32(),
            previous_head: service_state.trusted_slot,
            previous_wrapper_proof: previous_proof.as_ref().map(|p| p.bytes()),
            previous_wrapper_public_values: previous_proof
                .as_ref()
                .map(|p| p.public_values.to_vec()),
            previous_wrapper_vk: previous_proof.as_ref().map(|_| wrapper_vk.bytes32()),
        };

        let mut stdin = SP1Stdin::new();
        stdin.write_slice(&borsh::to_vec(&recursion_inputs).unwrap());

        let recursive_proof = client
            .prove(&recursive_pk, &stdin)
            .groth16()
            .run()
            .context("Failed to prove")?;

        let recursive_outputs: RecursionCircuitOutputs =
            borsh::from_slice(&recursive_proof.public_values.to_vec()).unwrap();

        let wrapper_inputs: WrapperCircuitInputs = WrapperCircuitInputs {
            recursive_proof: recursive_proof.bytes(),
            recursive_public_values: recursive_proof.public_values.to_vec(),
            recursive_vk: recursive_vk.bytes32(),
        };
        let mut stdin = SP1Stdin::new();
        stdin.write_slice(&borsh::to_vec(&wrapper_inputs).unwrap());

        let wrapper_proof = client
            .prove(&wrapper_pk, &stdin)
            .groth16()
            .run()
            .context("Failed to prove")?;

        service_state.most_recent_proof = Some(wrapper_proof.clone());
        service_state.trusted_slot = helios_outputs.newHead.try_into().unwrap();
        service_state.trusted_height = recursive_outputs.height;
        service_state.trusted_root = recursive_outputs.root.try_into().unwrap();

        println!("New Service State: {:?} \n", service_state);
        let elapsed_time = start_time.elapsed();
        println!("Alive for: {:?}", elapsed_time);
        service_state.update_counter += 1;
    }
}
